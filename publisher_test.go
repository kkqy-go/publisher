package publisher

import (
	"context"
	"reflect"
	"testing"
	"time"
)

// TestEvent is a simple event type for testing.
type TestEvent struct {
	ID         string
	IsSnapshot bool
	Key        string
}

// Config implements EventWithConfig for TestEvent.
func (e TestEvent) EventConfig() EventConfig {
	return EventConfig{
		Key:                        e.Key,
		AutoPublishToNewSubscriber: e.IsSnapshot,
	}
}

// TestSnapshotOrder verifies the event order with the final API.
func TestSnapshotOrder(t *testing.T) {
	// 1. Setup
	p := NewPublisher(
		WithNewSubscriberEventChannel[TestEvent](1),
		WithSubBufLen[TestEvent](10),
	)
	sourceCh := p.C()
	newSubEventCh := p.NewSubscriberC()
	defer p.Close()

	// Publish an internal snapshot event to populate eventMap
	internalSnapshotEvent := TestEvent{ID: "internal-1", IsSnapshot: true, Key: "key1"}

	// Sync block to ensure internalSnapshotEvent is processed and stored in eventMap
	{
		subCtx, cancel := context.WithCancel(context.Background())
		tempSub := p.Subscribe(subCtx)

		// Drain the NewSubscriberEvent generated by tempSub to avoid blocking the publisher
		// or confusing the external snapshot provider later.
		select {
		case <-newSubEventCh:
		case <-time.After(100 * time.Millisecond):
			t.Fatal("Timeout waiting for tempSub NewSubscriberEvent")
		}

		sourceCh <- internalSnapshotEvent
		select {
		case <-tempSub.C():
			// Event received, publisher has processed it.
		case <-time.After(1 * time.Second):
			t.Fatal("Timeout waiting for internal snapshot processing")
		}
		cancel()
	}

	// Channel to coordinate the order between external snapshot and live event
	snapshotSent := make(chan struct{})

	// 2. Start the external snapshot provider
	go func() {
		ctx := context.Background()
		select {
		case event := <-newSubEventCh:
			externalSnapshotEvent := TestEvent{ID: "external-1"}
			event.Send(ctx, externalSnapshotEvent)
			close(snapshotSent) // Signal that snapshot is sent
		case <-time.After(200 * time.Millisecond):
		}
	}()

	// 3. Subscribe
	subCtx, subCancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer subCancel()
	subscriber := p.Subscribe(subCtx)

	// 4. Publish a live event
	<-snapshotSent // Wait for external snapshot to be sent
	liveEvent := TestEvent{ID: "live-1"}
	sourceCh <- liveEvent

	// 5. Verification
	expectedOrder := []TestEvent{
		internalSnapshotEvent,
		{ID: "external-1"},
		liveEvent,
	}

	receivedEvents := make([]TestEvent, 0, len(expectedOrder))
	for i := 0; i < len(expectedOrder); i++ {
		select {
		case event := <-subscriber.C():
			receivedEvents = append(receivedEvents, event)
		case <-subCtx.Done():
			t.Fatalf("Test timed out. Received: %+v", receivedEvents)
		}
	}

	if !reflect.DeepEqual(expectedOrder, receivedEvents) {
		t.Errorf("Event order mismatch.\nExpected: %+v\nGot:      %+v", expectedOrder, receivedEvents)
	}
}

// TestSnapshot_SlowProviderWithSubscriberCancel verifies robustness with the final API.
func TestSnapshot_SlowProviderWithSubscriberCancel(t *testing.T) {
	// 1. Setup
	p := NewPublisher(WithNewSubscriberEventChannel[TestEvent](1))
	newSubEventCh := p.NewSubscriberC()
	defer p.Close()

	// 2. Setup a SLOW snapshot provider
	providerCommitDelay := 100 * time.Millisecond
	go func() {
		select {
		case subscriber := <-newSubEventCh:
			time.Sleep(providerCommitDelay)
			// Try to send. This should fail (subscriber cancelled) and trigger cleanup.
			subscriber.Send(context.Background(), TestEvent{ID: "late-snapshot"})
		case <-time.After(providerCommitDelay + 50*time.Millisecond):
		}
	}()

	// 3. Subscribe with a SHORT timeout
	subscriberTimeout := 20 * time.Millisecond
	subCtx, subCancel := context.WithTimeout(context.Background(), subscriberTimeout)
	defer subCancel()

	subscriber := p.Subscribe(subCtx)

	// 4. Verification
	select {
	case event, ok := <-subscriber.C():
		if ok {
			t.Fatalf("Received an unexpected event on a cancelled subscriber channel: %+v", event)
		}
	case <-time.After(providerCommitDelay + 50*time.Millisecond):
		t.Fatal("Test timed out: subscriber channel was not closed as expected.")
	}

	// 5. Final check for health of Subscribe on a running publisher
	healthCheckCtx, healthCheckCancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
	healthCheckCancel()
	p.Subscribe(healthCheckCtx) // This should not block

	if healthCheckCtx.Err() == context.DeadlineExceeded {
		t.Fatal("Publisher appears to be hung after a subscriber cancelled during snapshot.")
	}
}

// TestSubscribeOnClosedPublisher verifies that subscribing to a closed publisher
// immediately returns a closed subscriber.
func TestSubscribeOnClosedPublisher(t *testing.T) {
	p := NewPublisher[TestEvent]()
	p.Close()
	// Allow a moment for the Run goroutine to exit and cleanup
	subCtx, subCancel := context.WithTimeout(context.Background(), time.Millisecond*50)
	defer subCancel()
	closedSub := p.Subscribe(subCtx)
	// A read from the subscriber's channel should not block and should indicate the channel is closed.
	select {
	case event, ok := <-closedSub.C():
		if ok {
			t.Fatalf("Channel from a new subscriber on a closed publisher should be closed, but received event: %+v", event)
		}
		// Correct behavior: ok is false, meaning channel is closed.
	case <-time.After(time.Millisecond * 100):
		t.Fatal("Reading from a new subscriber's channel on a closed publisher blocked.")
	}

}
